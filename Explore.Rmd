---
title: "Exploratory Analysis"
author: "Alex Brown,David Geyfman, Jason Freeberg, Faraz Farooq"
date: "November 4, 2016"
output: pdf_document
---
## Introduction
Our dataset comes from a longitudinal study conducted in the United States. Researchers observed the time until divorce of 3371 couples, and tracked three covariates listed below. The data's time variable is measured in years with up to three decimals of precision. The event indicator is labeled 0 for censorship, and 1 for divorce.

  - The husband's education level, coded as...
      - 0 -> less than 12 years (only high school)
      - 1 -> 12 to 15 years (only bachelors or equivalent)
      - 2 -> 16 or more years (some form of graduate studies)
  - The husband's race, coded as...
      - 1 if the husband is black
      - 0 otherwise
  - Whether or not both partners are black, coded as...
      - 1 if both partners are **not** black
      - 0 if one parter is not black, and the other is
      
## Research question

Our team wanted to see how education affected time until divorce while controlling for 
the races of the couples. 

## Methodology

Our team decided to build our model bottom-up, meaning we fit a single covariate initially and added additional significant covariates.

## Exploratory Analysis of Covariates

The following plots explore the distributions of our covariates.

```{r, message=FALSE}
#loading necessary libraries
library(ggplot2)
library(survival)
library(cowplot)
library(devtools)
library(ggkm)


# Uncomment and 
# devtools::install_github("sachsmc/ggkm")
# https://github.com/sachsmc/ggkm

# Load data
colNames <- c("id", "edu", "hblack", "mixed", "years", "div")
divorce <- read.table(file = "divorce.txt", header = F, col.names = colNames)
head(divorce)
```
We turn the covariates into factors so we can group the covariate values as categories.
In order to focus on education we wanted to treat race as a controlled variable, instead of having two covariates involving race, we made a new column that fully encodes the couple's racial makeup. 

```{r, echo = FALSE}
divorce$edu <- as.factor(divorce$edu)
divorce$hblack <- as.factor(divorce$hblack)
divorce$mixed <- as.factor(divorce$mixed)

# Function to make the wife's race
femalecol <- function(dataframe){
  dataframe$wblack <- as.factor(
    
    ifelse(dataframe$hblack == dataframe$mixed & dataframe$hblack == 1, 0, 
           ifelse(dataframe$hblack == 1 & dataframe$mixed == 0, 1,
                  ifelse(dataframe$hblack == 0 & dataframe$mixed == 1, 1, 0)))
  
    )
  
  return(dataframe)
}

# Encode column
couple_column <- function(dataframe){
  # Encodes couple's race into one column
  # Husband's race first, then wife's race
  # BB => Black and Black
  # BO => Black and Other
  # OB => Other and Black
  # OO => Other and Other
  
  dataframe$couple <- as.factor(
    ifelse(dataframe$hblack == 1 & dataframe$wblack == 1, "BB", 
           ifelse(dataframe$hblack == 1 & dataframe$wblack == 0, "BO", 
                  ifelse(dataframe$hblack == 0 & dataframe$wblack == 1, "OB", "OO")))
  )
  return(dataframe)
}

divorce <- femalecol(divorce)
divorce <- couple_column(divorce)
# Define the neatPrint function, makes for nicer output in Rmarkdown
neatPrint <- function(listOfStrings){
  cat(listOfStrings, fill = 1)
}

# Define the ggsurv function, credit and link are below
ggsurv <- function(s, CI = 'def', plot.cens = T, surv.col = 'gg.def',
                   cens.col = 'red', lty.est = 1, lty.ci = 2,
                   cens.shape = 3, back.white = F, xlab = 'Time',
                   ylab = 'Survival', main = ''){
 
  library(ggplot2)
  strata <- ifelse(is.null(s$strata) ==T, 1, length(s$strata))
  stopifnot(length(surv.col) == 1 | length(surv.col) == strata)
  stopifnot(length(lty.est) == 1 | length(lty.est) == strata)
 
  ggsurv.s <- function(s, CI = 'def', plot.cens = T, surv.col = 'gg.def',
                       cens.col = 'red', lty.est = 1, lty.ci = 2,
                       cens.shape = 3, back.white = F, xlab = 'Time',
                       ylab = 'Survival', main = ''){
 
    dat <- data.frame(time = c(0, s$time),
                      surv = c(1, s$surv),
                      up = c(1, s$upper),
                      low = c(1, s$lower),
                      cens = c(0, s$n.censor))
    dat.cens <- subset(dat, cens != 0)
 
    col <- ifelse(surv.col == 'gg.def', 'black', surv.col)
 
    pl <- ggplot(dat, aes(x = time, y = surv)) +
      xlab(xlab) + ylab(ylab) + ggtitle(main) +
      geom_step(col = col, lty = lty.est)
 
    pl <- if(CI == T | CI == 'def') {
      pl + geom_step(aes(y = up), color = col, lty = lty.ci) +
        geom_step(aes(y = low), color = col, lty = lty.ci)
    } else (pl)
 
    pl <- if(plot.cens == T & length(dat.cens) > 0){
      pl + geom_point(data = dat.cens, aes(y = surv), shape = cens.shape,
                       col = cens.col)
    } else if (plot.cens == T & length(dat.cens) == 0){
      stop ('There are no censored observations')
    } else(pl)
 
    pl <- if(back.white == T) {pl + theme_bw()
    } else (pl)
    pl
  }
 
  ggsurv.m <- function(s, CI = 'def', plot.cens = T, surv.col = 'gg.def',
                       cens.col = 'red', lty.est = 1, lty.ci = 2,
                       cens.shape = 3, back.white = F, xlab = 'Time',
                       ylab = 'Survival', main = '') {
    n <- s$strata
 
    groups <- factor(unlist(strsplit(names
                                     (s$strata), '='))[seq(2, 2*strata, by = 2)])
    gr.name <-  unlist(strsplit(names(s$strata), '='))[1]
    gr.df <- vector('list', strata)
    ind <- vector('list', strata)
    n.ind <- c(0,n); n.ind <- cumsum(n.ind)
    for(i in 1:strata) ind[[i]] <- (n.ind[i]+1):n.ind[i+1]
 
    for(i in 1:strata){
      gr.df[[i]] <- data.frame(
        time = c(0, s$time[ ind[[i]] ]),
        surv = c(1, s$surv[ ind[[i]] ]),
        up = c(1, s$upper[ ind[[i]] ]),
        low = c(1, s$lower[ ind[[i]] ]),
        cens = c(0, s$n.censor[ ind[[i]] ]),
        group = rep(groups[i], n[i] + 1))
    }
 
    dat <- do.call(rbind, gr.df)
    dat.cens <- subset(dat, cens != 0)
 
    pl <- ggplot(dat, aes(x = time, y = surv, group = group)) +
      xlab(xlab) + ylab(ylab) + ggtitle(main) +
      geom_step(aes(col = group, lty = group))
 
    col <- if(length(surv.col == 1)){
      scale_colour_manual(name = gr.name, values = rep(surv.col, strata))
    } else{
      scale_colour_manual(name = gr.name, values = surv.col)
    }
 
    pl <- if(surv.col[1] != 'gg.def'){
      pl + col
    } else {pl + scale_colour_discrete(name = gr.name)}
 
    line <- if(length(lty.est) == 1){
      scale_linetype_manual(name = gr.name, values = rep(lty.est, strata))
    } else {scale_linetype_manual(name = gr.name, values = lty.est)}
 
    pl <- pl + line
 
    pl <- if(CI == T) {
      if(length(surv.col) > 1 && length(lty.est) > 1){
        stop('Either surv.col or lty.est should be of length 1 in order
             to plot 95% CI with multiple strata')
      }else if((length(surv.col) > 1 | surv.col == 'gg.def')[1]){
        pl + geom_step(aes(y = up, color = group), lty = lty.ci) +
          geom_step(aes(y = low, color = group), lty = lty.ci)
      } else{pl +  geom_step(aes(y = up, lty = group), col = surv.col) +
               geom_step(aes(y = low,lty = group), col = surv.col)}
    } else {pl}
 
 
    pl <- if(plot.cens == T & length(dat.cens) > 0){
      pl + geom_point(data = dat.cens, aes(y = surv), shape = cens.shape,
                      col = cens.col)
    } else if (plot.cens == T & length(dat.cens) == 0){
      stop ('There are no censored observations')
    } else(pl)
 
    pl <- if(back.white == T) {pl + theme_bw()
    } else (pl)
    pl
  }
  pl <- if(strata == 1) {ggsurv.s(s, CI , plot.cens, surv.col ,
                                  cens.col, lty.est, lty.ci,
                                  cens.shape, back.white, xlab,
                                  ylab, main)
  } else {ggsurv.m(s, CI, plot.cens, surv.col ,
                   cens.col, lty.est, lty.ci,
                   cens.shape, back.white, xlab,
                   ylab, main)}
  pl
}
```


```{r, echo=FALSE, message = FALSE}
a <- ggplot(divorce) + 
  geom_density(mapping = (aes(x=years, fill = as.factor(div), group = div)), alpha = .5)+
  ggtitle("Distribution of Censored and\n Non-Censored Observations")+
  theme(legend.title = element_blank())

# Get proportions of mixed couples in each education bracket
edu_counts <- as.data.frame.matrix(table(divorce$edu, divorce$mixed))
names(edu_counts) = c("no_mix", "mixed")
row.names(edu_counts) = c("HS", "BA", "MA")

mixed_HS = paste(round( (edu_counts$mixed[1] / sum(edu_counts[1,])), 2) * 100, "%", sep = "")
mixed_BA = paste(round( (edu_counts$mixed[2] / sum(edu_counts[2,])), 2) * 100, "%", sep = "")
mixed_MA = paste(round( (edu_counts$mixed[3] / sum(edu_counts[3,])), 2) * 100, "%", sep = "")

appending_text = "\n mixed race"
HS_text = paste(mixed_HS, appending_text)
BA_text = paste(mixed_BA, appending_text)
MA_text = paste(mixed_MA, appending_text)
proportions = c(HS_text, BA_text, MA_text)

b <- ggplot(divorce)+
  geom_bar(mapping = aes(x=edu, fill = as.factor(hblack))) +
  geom_text(mapping = aes(x=edu), label = proportions, stat="count") +
  ggtitle("Frequency of Education Levels \n Colored by Male's Race") +
  xlab("Education Level") +
  theme(legend.title = element_blank())

plot_grid(a,b)
```

**Left** We can see that the bulk of our observed divorces, colored in blue, occur around the ten year mark. Our censored observations, colored in orange, drop steeply at 30 years into the study. 

**Right** This plot shows the frequency of different education levels in our data. The bars are colored by their proportion of black husbands within the education level. So we can see that our data is largely composed of couples with husbands that are not African American. Lastly, the percentages over each bar report the percent of mixed race coupled within their respective education bracket. For example, 27% of couples in education bracket **0** are mixed.

## Exploratory Survival Curves

```{r, echo = FALSE, message=FALSE}
divorcefit <- Surv(time = divorce$years, event = divorce$div)
divorceKM <- survfit(divorcefit ~ 1)
educateKM <- survfit(divorcefit ~ divorce$edu)


a <- ggsurv(divorceKM, plot.cens = F) +
  ggtitle("Baseline Model") +
  ylab("Survival Probability") +
  xlab("Time in Years") + ylab("Probability")

b <- ggsurv(educateKM, plot.cens = F) +
  ggtitle("Estimates by Education Level") +
  ylab("Survival Probability") +
  xlab("Time in Years") +
  theme(legend.title = element_blank()) + ylab("Probability")
c <- NULL



plot_grid(a,b,c, nrow = 2, ncol = 2, label_size = 10)
```
Plot analysis clockwise from top left.

**Top Left** Thanks to the large number of observations, our KM estimate is nearly a smooth line.

**Top Right** This plot is especially interesting, as one would expect there to be a linear relationship between the education levels and the respective hazard rates... for example, $S_{1}(X) < S_{2}(X) < S_{3}(X)$ (where $S_{i}$ denotes the survival function of the ith education level). Interestingly, we do not see this trend. The survival rates of couples with a college-educated husband are visibly lower than that of couples with either a high-school educated or graduate-educated husband.

**Bottom Right** 

**Bottom Left** Non-mixed couples are likely to survive longer, shown by their higher survival function and that their observations carried on longer into the study.

## Modeling


```{r}
edu_coxph <- coxph(Surv(years, div) ~ edu, data = divorce)

edu_coxph
```

Our base model is significant ..... 

## Control for Racial Makeup

Add racial covariates to model with education, and make sure education is a significant predictor in all.

```{r}
eh_coxph <- coxph(Surv(years,div) ~ edu + hblack, data=divorce)
em_coxph <- coxph(Surv(years,div) ~ edu + mixed, data=divorce)
emb_coxph <- coxph(Surv(years,div) ~ edu + mixed + hblack , data=divorce)
embw_coxph <- coxph(Surv(years,div) ~ edu + mixed + hblack + wblack, data=divorce)

eh_coxph
em_coxph
emb_coxph
embw_coxph
```

Now that we know education is a significant predictor even when controlled for racial makeup, we will find the best model from the ones above.

## Effect of Racial Makeup

```{r}
BIC(edu_coxph)
BIC(eh_coxph)
BIC(em_coxph)
BIC(emb_coxph)
BIC(embw_coxph)

edu_couple_coxph <- coxph(Surv(years, div) ~ edu + couple, data = divorce)
BIC(edu_couple_coxph)

# Make this shit print better
```

Although the BIC on the model using education and mixed couple was the lowest, we decided to continue our analysis using a new variable, "couple" which encodes all the racial makeups into one predictor. Below, we test the difference between the two to ensure there is no statistical difference.

We are testing to see if there is a significant difference between the model using the newly encoded predictor, and the model containing the individual predictors being encoded.

```{r}
chi_test <- 2*(edu_couple_coxph$loglik[[2]] - em_coxph$loglik[[2]])

# 5 parameters in the bigger model (lots of factor levels)
# 3 parameters in the restricted model
1 - pchisq(chi_test, df = 5-3)
```

The P-value is 0.075, which is above any common significance level. Therefore, there is no significant difference between the two models using...

  - Education + Couple
  - Education + Mixed

This allows us to use a more condensed predictor for interaction terms later. Lastly, it is interesting to note that the model using Education + Mixed + Hblack + Wblack is in fact the same model as Education + Couple.

## Checking Proportional Hazard Assumptions 

### Graphical Approach
```{r, echo = FALSE, message = FALSE}
# Make more ticks marks on the X axis
a <- ggplot(divorce, mapping = aes(time = years, status = div, color = edu)) +
  geom_km(trans = "cloglog") + 
  ylab("Complementary Log-Log") + 
  ggtitle("Log-Log curve for Education level") +
  ylab("Y") +
  scale_x_log10() +
  theme(legend.title = element_blank())

b <- ggplot(divorce, mapping = aes(time = years, status = div, color = couple)) +
  geom_km(trans = "cloglog") +
  ylab("Complementary Log-Log") + 
  ggtitle("Log-Log curve for Couple Makeup") +
  ylab("Y") +
  scale_x_log10() +
  theme(legend.title = element_blank())

plot_grid(a,b)
```

**Left** The intersecting lines are concerning, so we will investigate the necessity of a time-transformation on education.

**Right** Again, the intersecting lines are concerning. In this case, however, we will investigate the necesity of stratifying the racial makeup predictor.

### Numerical Approach
```{r}
edu_zph <- cox.zph(edu_coxph)
edu_couple_zph <- cox.zph(edu_couple_coxph)

edu_zph
edu_couple_zph
```

While our numerical test indicates that education does **not** violate the proportional hazards assumption, we will still investigate the improvement of adding a time-transformation

The numerical test for racial makeup of the couple confirms the suspicions from the c-log-log plot. The predictor does violate the proportional hazards assumption and we will then use it as a stratified variable.

## Time Transform

## Stratification

